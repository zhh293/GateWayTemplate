# 书写过程中我也遇到了很多困难，这期间也在不断复习网关，下面是我总结出来的网关的基本知识



## 首先了解网关为什么存在
一、先解决核心困惑：网关到底为什么存在？
你可以把网关理解成小区门口的保安 + 快递代收点 + 访客登记处，没有它会乱成一锅粥，核心作用就 3 个：
统一入口，不用记一堆地址比如你做一个电商 APP，背后有 “用户服务”“订单服务”“商品服务”，每个服务都有自己的 IP 和端口。没有网关的话，APP 要记住 3 个地址分别调用；有了网关，APP 只需要调用网关一个地址，剩下的 “该找谁” 让网关来定。
集中处理 “通用活儿”，避免重复劳动认证（登录没）、限流（别一下子冲垮服务）、日志（谁访问了）这些功能，每个服务都写一遍太麻烦。网关把这些 “通用活儿” 全接了，服务只需要专注处理自己的业务（比如订单服务只管创建订单）。
隔离内外，保护服务安全网关相当于 “城墙”，外部请求必须经过网关才能到内部服务，直接访问服务的路径被完全挡住，能有效防止恶意攻击。



## 网关的核心原理
二、网关的核心原理：就做 2 件事 ——“判断” 和 “转发”
网关的工作流程特别简单，就像快递员送快递，一步到位：
接收请求：用户 / APP 的请求先到网关（比如请求 “查我的订单”）。
判断路由（该发给谁）：网关根据规则判断 “查订单” 属于 “订单服务”，找到订单服务的地址。
过滤处理（中间加活儿）：判断用户有没有登录（没登录就返回 “请登录”）、当前请求是不是太多（太多就限流）。
转发请求：把处理后的请求发给订单服务。
返回结果：订单服务把 “订单列表” 返回给网关，网关再转发给用户 / APP。
一句话总结：网关是 “请求的中转站 + 过滤器”，不做业务逻辑，只做 “路由” 和 “通用处理”。


## 网关实战
1. 第一步：引入依赖（Maven）
   先在pom.xml里加网关的依赖，注意要和你的 Spring Cloud 版本匹配
```aiignore
<!-- 网关核心依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<!-- 如果用Nacos/Eureka做服务发现，加这个依赖（可选） -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```
2. 第二步：配置路由（最核心的一步）
   路由配置有 2 种方式：yml配置文件（推荐，简单）和Java代码配置（灵活），先看最常用的 yml 配置。
   方式 1：yml 配置（application.yml）
   这个配置实现了 2 个功能：
   路径是/order/**的请求，转发到 “订单服务”（用服务名lb://order-service，lb 代表负载均衡）；
   路径是/user/**的请求，转发到 “用户服务”，并且给请求加一个 “source=gateway” 的请求头。
```aiignore
spring:
  application:
    name: gateway-service # 网关自己的服务名
  cloud:
    # 服务发现（如果用Nacos，配置这个）
    nacos:
      discovery:
        server-addr: localhost:8848 # Nacos地址
    # 网关核心配置
    gateway:
      routes:
        # 第一个路由：订单服务
        - id: order-service-route # 路由唯一ID（随便起）
          uri: lb://order-service # 转发的目标服务名（lb=负载均衡）
          predicates: # 断言（判断条件）
            - Path=/order/** # 路径匹配：只要路径以/order开头就走这个路由
          filters: # 过滤器（给请求加请求头）
            - AddRequestHeader=source, gateway # 给请求加一个header：source=gateway
        # 第二个路由：用户服务
        - id: user-service-route
          uri: lb://user-service
          predicates:
            - Path=/user/**
            - Method=GET # 只接收GET请求（多个断言是“且”的关系）
```
方式 2：Java 代码配置（适合复杂规则）
如果需要动态生成路由（比如从数据库读规则），可以用代码配置，新建一个GatewayConfig类：
```aiignore
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                 订单服务路由
                .route("order-service-route", r -> r
                        .path("/order/**") // 路径断言
                        .uri("lb://order-service")) // 转发地址
                 用户服务路由（加请求头过滤器）
                .route("user-service-route", r -> r
                        .path("/user/**")
                        .filters(f -> f.addRequestHeader("source", "gateway")) // 加请求头
                        .uri("lb://user-service"))
                .build();
    }
}
```
3. 第三步：自定义过滤器（实现登录认证）
   前面的AddRequestHeader是网关自带的过滤器，实际项目中常用 “自定义过滤器”，比如实现 “登录认证”—— 判断请求头里有没有token，没有就返回 401。
   新建一个LoginFilter类，实现GlobalFilter（全局过滤器，所有请求都会经过）：
```aiignore


@Configuration
public class LoginFilter {

     自定义全局过滤器（Order值越小，执行顺序越靠前）
    @Bean
    @Order(-1) // 优先级：比默认过滤器高
    public GlobalFilter loginAuthFilter() {
        return (exchange, chain) -> {
             1. 获取请求头里的token
            String token = exchange.getRequest().getHeaders().getFirst("token");
             2. 判断token是否为空
            if (token == null || token.isEmpty()) {
                 3. 没有token，返回401（未授权）
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete(); // 结束请求
            }
             4. 有token（这里可以加验证token的逻辑，比如查Redis）
             5. 验证通过，继续转发请求到服务
            return chain.filter(exchange);
        };
    }
}
```
4. 第四步：测试验证
   启动 Nacos（如果用了服务发现）、网关服务、订单服务、用户服务；
   用 Postman 发请求：GET http://localhost:8080/order/1（网关端口是 8080）；
   如果请求头没加token，会返回 401；
   加token后，会转发到订单服务，返回订单 ID=1 的信息。
5. 五、总结：网关的核心价值
   对前端 / 用户：只需要记一个网关地址，不用管背后有多少服务；
   对后端开发：不用在每个服务里写认证、限流，专注业务逻辑；
   对运维：统一监控、统一限流，服务出问题时网关还能做降级（比如返回 “服务维护中”）。